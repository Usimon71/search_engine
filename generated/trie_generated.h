// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_TRIE_H_
#define FLATBUFFERS_GENERATED_TRIE_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 25,
             "Non-compatible flatbuffers version included");

struct Doc;
struct DocBuilder;

struct NextMap;
struct NextMapBuilder;

struct Node;
struct NodeBuilder;

struct Trie;
struct TrieBuilder;

struct Doc FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef DocBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_FREQ = 6,
    VT_STRING_NO = 8
  };
  uint64_t id() const {
    return GetField<uint64_t>(VT_ID, 0);
  }
  uint64_t freq() const {
    return GetField<uint64_t>(VT_FREQ, 0);
  }
  const ::flatbuffers::Vector<uint64_t> *string_no() const {
    return GetPointer<const ::flatbuffers::Vector<uint64_t> *>(VT_STRING_NO);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_ID, 8) &&
           VerifyField<uint64_t>(verifier, VT_FREQ, 8) &&
           VerifyOffset(verifier, VT_STRING_NO) &&
           verifier.VerifyVector(string_no()) &&
           verifier.EndTable();
  }
};

struct DocBuilder {
  typedef Doc Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_id(uint64_t id) {
    fbb_.AddElement<uint64_t>(Doc::VT_ID, id, 0);
  }
  void add_freq(uint64_t freq) {
    fbb_.AddElement<uint64_t>(Doc::VT_FREQ, freq, 0);
  }
  void add_string_no(::flatbuffers::Offset<::flatbuffers::Vector<uint64_t>> string_no) {
    fbb_.AddOffset(Doc::VT_STRING_NO, string_no);
  }
  explicit DocBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Doc> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Doc>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Doc> CreateDoc(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t id = 0,
    uint64_t freq = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint64_t>> string_no = 0) {
  DocBuilder builder_(_fbb);
  builder_.add_freq(freq);
  builder_.add_id(id);
  builder_.add_string_no(string_no);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Doc> CreateDocDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t id = 0,
    uint64_t freq = 0,
    const std::vector<uint64_t> *string_no = nullptr) {
  auto string_no__ = string_no ? _fbb.CreateVector<uint64_t>(*string_no) : 0;
  return CreateDoc(
      _fbb,
      id,
      freq,
      string_no__);
}

struct NextMap FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef NextMapBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CHR = 4,
    VT_REF = 6
  };
  int8_t chr() const {
    return GetField<int8_t>(VT_CHR, 0);
  }
  bool KeyCompareLessThan(const NextMap * const o) const {
    return chr() < o->chr();
  }
  int KeyCompareWithValue(int8_t _chr) const {
    return static_cast<int>(chr() > _chr) - static_cast<int>(chr() < _chr);
  }
  uint64_t ref() const {
    return GetField<uint64_t>(VT_REF, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_CHR, 1) &&
           VerifyField<uint64_t>(verifier, VT_REF, 8) &&
           verifier.EndTable();
  }
};

struct NextMapBuilder {
  typedef NextMap Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_chr(int8_t chr) {
    fbb_.AddElement<int8_t>(NextMap::VT_CHR, chr, 0);
  }
  void add_ref(uint64_t ref) {
    fbb_.AddElement<uint64_t>(NextMap::VT_REF, ref, 0);
  }
  explicit NextMapBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<NextMap> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<NextMap>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<NextMap> CreateNextMap(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int8_t chr = 0,
    uint64_t ref = 0) {
  NextMapBuilder builder_(_fbb);
  builder_.add_ref(ref);
  builder_.add_chr(chr);
  return builder_.Finish();
}

struct Node FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef NodeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DOCS = 4,
    VT_NEXT = 6,
    VT_IS_TERMINAL = 8
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<Doc>> *docs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<Doc>> *>(VT_DOCS);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<NextMap>> *next() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<NextMap>> *>(VT_NEXT);
  }
  bool is_terminal() const {
    return GetField<uint8_t>(VT_IS_TERMINAL, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DOCS) &&
           verifier.VerifyVector(docs()) &&
           verifier.VerifyVectorOfTables(docs()) &&
           VerifyOffset(verifier, VT_NEXT) &&
           verifier.VerifyVector(next()) &&
           verifier.VerifyVectorOfTables(next()) &&
           VerifyField<uint8_t>(verifier, VT_IS_TERMINAL, 1) &&
           verifier.EndTable();
  }
};

struct NodeBuilder {
  typedef Node Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_docs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Doc>>> docs) {
    fbb_.AddOffset(Node::VT_DOCS, docs);
  }
  void add_next(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<NextMap>>> next) {
    fbb_.AddOffset(Node::VT_NEXT, next);
  }
  void add_is_terminal(bool is_terminal) {
    fbb_.AddElement<uint8_t>(Node::VT_IS_TERMINAL, static_cast<uint8_t>(is_terminal), 0);
  }
  explicit NodeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Node> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Node>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Node> CreateNode(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Doc>>> docs = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<NextMap>>> next = 0,
    bool is_terminal = false) {
  NodeBuilder builder_(_fbb);
  builder_.add_next(next);
  builder_.add_docs(docs);
  builder_.add_is_terminal(is_terminal);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Node> CreateNodeDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<Doc>> *docs = nullptr,
    std::vector<::flatbuffers::Offset<NextMap>> *next = nullptr,
    bool is_terminal = false) {
  auto docs__ = docs ? _fbb.CreateVector<::flatbuffers::Offset<Doc>>(*docs) : 0;
  auto next__ = next ? _fbb.CreateVectorOfSortedTables<NextMap>(next) : 0;
  return CreateNode(
      _fbb,
      docs__,
      next__,
      is_terminal);
}

struct Trie FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TrieBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NODES = 4,
    VT_ROOT = 6
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<Node>> *nodes() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<Node>> *>(VT_NODES);
  }
  const Node *root() const {
    return GetPointer<const Node *>(VT_ROOT);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NODES) &&
           verifier.VerifyVector(nodes()) &&
           verifier.VerifyVectorOfTables(nodes()) &&
           VerifyOffset(verifier, VT_ROOT) &&
           verifier.VerifyTable(root()) &&
           verifier.EndTable();
  }
};

struct TrieBuilder {
  typedef Trie Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_nodes(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Node>>> nodes) {
    fbb_.AddOffset(Trie::VT_NODES, nodes);
  }
  void add_root(::flatbuffers::Offset<Node> root) {
    fbb_.AddOffset(Trie::VT_ROOT, root);
  }
  explicit TrieBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Trie> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Trie>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Trie> CreateTrie(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Node>>> nodes = 0,
    ::flatbuffers::Offset<Node> root = 0) {
  TrieBuilder builder_(_fbb);
  builder_.add_root(root);
  builder_.add_nodes(nodes);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Trie> CreateTrieDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<Node>> *nodes = nullptr,
    ::flatbuffers::Offset<Node> root = 0) {
  auto nodes__ = nodes ? _fbb.CreateVector<::flatbuffers::Offset<Node>>(*nodes) : 0;
  return CreateTrie(
      _fbb,
      nodes__,
      root);
}

inline const Trie *GetTrie(const void *buf) {
  return ::flatbuffers::GetRoot<Trie>(buf);
}

inline const Trie *GetSizePrefixedTrie(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<Trie>(buf);
}

inline bool VerifyTrieBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<Trie>(nullptr);
}

inline bool VerifySizePrefixedTrieBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<Trie>(nullptr);
}

inline void FinishTrieBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<Trie> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedTrieBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<Trie> root) {
  fbb.FinishSizePrefixed(root);
}

#endif  // FLATBUFFERS_GENERATED_TRIE_H_
